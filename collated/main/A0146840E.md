# A0146840E
###### \java\seedu\tasklist\logic\commands\AddCommand.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        final Matcher matcher = TASK_DATA_ARGS_FORMAT.matcher(args.trim());
        
        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }
        
        try {
            return new AddCommand(
                    matcher.group("title"),
                    getDetailsFromArgs(matcher.group("startDateTime")),
                    getDetailsFromArgs(matcher.group("description")),
                    getDetailsFromArgs(matcher.group("endDateTime")),
                    getTagsFromArgs(matcher.group("tagArguments"))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\tasklist\logic\commands\ClearCommand.java
``` java
    @Override
    public Command prepare(String args) {
        return new ClearCommand();
    }
}
```
###### \java\seedu\tasklist\logic\commands\DeleteCommand.java
``` java
	/**
	 * Parses arguments in the context of the delete task command.
	 *
	 * @param args
	 *            full command args string
	 * @return the prepared command
	 */
	@Override
	public Command prepare(String args) {
		Optional<Integer> index = parseIndex(args);
		if (!index.isPresent()) {
			return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
		}

		return new DeleteCommand(index.get());
	}

}
```
###### \java\seedu\tasklist\logic\commands\EditCommand.java
``` java
/**
 * Edit a task in the task list.
 */
public class EditCommand extends CommandUndoExtension {
    public static final String COMMAND_WORD = "edit";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Edits the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX [TITLE] [d/DESCRIPTION] [s/START DATE TIME] [e/END DATE TIME] [t/TAG]\n" + "Example: \n"
            + COMMAND_WORD + " 1 NEW_TITLE d/NEW_DESCRIPTION\n"
            + COMMAND_WORD + " 2 e/12122012 2359\n"
            + COMMAND_WORD + " 3 t/TAG1 t/TAG2";

    private static final String MESSAGE_EDIT_TASK_SUCCESS = "Edited task: %1$s";

    private int targetIndex;
    private Task toEdit;
    private Task beforeEdit;
    private Task afterEdit;

    public EditCommand() {};
    
    /**
     * Edit a task identified using it's last displayed index from the task list.
     * 
     * @throws IllegalValueException if input contains invalid format
     */
    public EditCommand(int targetIndex, String title, String startDateTime, String description, String endDateTime,
            Set<String> tags) throws IllegalValueException {
        this.targetIndex = targetIndex;

        final Set<Tag> tagSet = new HashSet<>();
        for (String tagName : tags) {
            tagSet.add(new Tag(tagName));
        }
        
        this.toEdit = new Task(new Title(title), new DateTime(startDateTime), new Description(description),
                new DateTime(endDateTime), new UniqueTagList(tagSet));
    }

    @Override
    public CommandResult execute() {
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToEdit = lastShownList.get(targetIndex - 1);
        beforeEdit = (Task) taskToEdit;

        try {
            Task editedTask = editTask(taskToEdit);
            afterEdit = editedTask;
            model.editTask(editedTask, taskToEdit);
            CommandHistory.addCommandHistory(this);
        } catch (TaskNotFoundException tnfe) {
            assert false : "The target task cannot be missing";
        } catch (IllegalValueException e) {
            return new CommandResult(String.format(e.getMessage()));
        }
        return new CommandResult(String.format(MESSAGE_EDIT_TASK_SUCCESS, taskToEdit));
    }
    
```
###### \java\seedu\tasklist\logic\commands\EditCommand.java
``` java
    /**
     * Combines the new editions with its original task
     * 
     * @param taskToEdit containing the parameters to change
     * @return new edited task
     * @throws IllegalValueException if input contains invalid format
     */
    private Task editTask(ReadOnlyTask taskToEdit) throws IllegalValueException {
        return new Task(editTitle(taskToEdit), editStartDateTime(taskToEdit), editDescription(taskToEdit),
                        editEndDateTime(taskToEdit), editTags(taskToEdit));
    }
    
    /**
     * Retrieve a Title by replacing the original Title with the new Title, if any.
     * 
     * @param taskToEdit containing the parameters to change
     * @return Title with the edited Title
     */
    private Title editTitle(ReadOnlyTask taskToEdit) {
        return this.toEdit.getTitle().toString().equals("") ? taskToEdit.getTitle() : this.toEdit.getTitle();
    }
    
    /**
     * Retrieve a Description by replacing the original Description with the new Description, if any.
     * 
     * @param taskToEdit containing the parameters to change
     * @return Description with the edited Description
     */
    private Description editDescription(ReadOnlyTask taskToEdit) {
        return this.toEdit.getDescription().toString().equals("") ? taskToEdit.getDescription() : this.toEdit.getDescription();
    }
    
    /**
     * Retrieve a DateTime by replacing the original DateTime with the new DateTime, if any.
     * 
     * @param taskToEdit containing the parameters to change
     * @return DateTime with the edited DateTime 
     * @throws IllegalValueException if invalid DateTime format
     */
    private DateTime editStartDateTime(ReadOnlyTask taskToEdit) throws IllegalValueException {
        DateTime startDateTime = new DateTime();
        startDateTime.setDate(this.toEdit.getStartDateTime().getDate().toString().equals("") ? taskToEdit.getStartDateTime().getDate() : this.toEdit.getStartDateTime().getDate());
        startDateTime.setTime(this.toEdit.getStartDateTime().getTime().toString().equals("") ? taskToEdit.getStartDateTime().getTime() : this.toEdit.getStartDateTime().getTime());
        return startDateTime;
    }
    
    /**
     * Retrieve a DateTime by replacing the original DateTime with the new DateTime, if any.
     * 
     * @param taskToEdit containing the parameters to change
     * @return DateTime with the edited DateTime 
     * @throws IllegalValueException if invalid DateTime format
     */
    private DateTime editEndDateTime(ReadOnlyTask taskToEdit) throws IllegalValueException {
        DateTime endDateTime = new DateTime();
        endDateTime.setDate(this.toEdit.getEndDateTime().getDate().toString().equals("") ? taskToEdit.getEndDateTime().getDate() : this.toEdit.getEndDateTime().getDate());
        endDateTime.setTime(this.toEdit.getEndDateTime().getTime().toString().equals("") ? taskToEdit.getEndDateTime().getTime() : this.toEdit.getEndDateTime().getTime());
        return endDateTime;
    }
    
    /**
     * Retrieve a UniqueTagList by replacing the original Tags with the new Tags, if any.
     * 
     * @param taskToEdit containing the parameters to change
     * @return UniqueTagList containing the edited Tags
     */
    private UniqueTagList editTags(ReadOnlyTask taskToEdit) {
        return this.toEdit.getTags().getInternalList().isEmpty() ? new UniqueTagList(taskToEdit.getTags()) : new UniqueTagList(this.toEdit.getTags());
    }
    
    /**
     * Parses arguments in the context of the edit task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        final Matcher matcher = EDIT_TASK_DATA_ARGS_FORMAT.matcher(args.trim());

        // Validate arg string format
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }
        
        // Validate arg index
        Optional<Integer> index = parseIndex(matcher.group("targetIndex"));
        
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }
        
        try {            
            return new EditCommand(
                    index.get(),
                    matcher.group("title"),
                    getDetailsFromArgs(matcher.group("startDateTime")),
                    getDetailsFromArgs(matcher.group("description")),
                    getDetailsFromArgs(matcher.group("endDateTime")),
                    getTagsFromArgs(matcher.group("tagArguments"))
            );
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        }
    }

}
```
###### \java\seedu\tasklist\logic\commands\FindCommand.java
``` java
    /**
     * Parses arguments in the context of the find task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        final Matcher matcher = KEYWORDS_ARGS_FORMAT.matcher(args.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                    MESSAGE_USAGE));
        }

        // keywords delimited by whitespace
        final String[] keywords = matcher.group("keywords").split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        return new FindCommand(keywordSet);
    }

}
```
###### \java\seedu\tasklist\logic\commands\HelpCommand.java
``` java
    /**
     * Parses arguments in the context of the help command.
     *
     * @param args should be empty
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        return new HelpCommand();
    }
}
```
###### \java\seedu\tasklist\logic\commands\IncorrectCommand.java
``` java
    /**
     * Parses arguments in the context of the incorrect command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        return new IncorrectCommand(args);
    }

}

```
###### \java\seedu\tasklist\logic\commands\ListCommand.java
``` java
/**
 * List tasks
 */
public class ListCommand extends Command {

    public static final String COMMAND_WORD = "list";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": List tasks in the task list. \n"
            + "Parameters: [TYPE]\nTYPE: completed, overdue, floating, today or week\n" + "Example: \n" + COMMAND_WORD + " \n"
            + COMMAND_WORD + " completed\n" + COMMAND_WORD + " overdue\n" + COMMAND_WORD + " floating";

    public static final String MESSAGE_SUCCESS = "Listed all %1$stasks.";
    public static final String MESSAGE_SUCCESS_2 = "Listed all tasks for %1$s.";
    public static final String MESSAGE_NO_TASK_TODAY = "Great! You have no tasks for today!";
    public static final String MESSAGE_NO_TASK_WEEK = "Wow! You have no tasks for the week!";

    private enum List {
        ALL, COMPLETED_TASKS, OVERDUE_TASKS, FLOATING_TASKS, TODAY_TASKS, WEEK_TASKS
    }

    private ListCommand.List type;

    public ListCommand() {}

    /**
     * Lists tasks in the task list to the user.
     * 
     * @param args
     *            containing the requested parameter
     * @throws IllegalValueException
     *             if list command arguments are invalid
     */
    public ListCommand(String args) throws IllegalValueException {
        switch (args.trim()) {
            case "" :
                type = ListCommand.List.ALL;
                break;
                
            case "completed" :
                type = ListCommand.List.COMPLETED_TASKS;
                break;
                
            case "overdue":
                type = ListCommand.List.OVERDUE_TASKS;
                break;
                
            case "floating":
                type = ListCommand.List.FLOATING_TASKS;
                break;
                
            case "today" :
                type = ListCommand.List.TODAY_TASKS;
                break;
                
            case "week" :
                type = ListCommand.List.WEEK_TASKS;
                break;
                
            default :
                throw new IllegalValueException("");
        }
    }

    @Override
    public CommandResult execute() {
        int filteredListSize;
        switch (type) {
            case ALL :
                model.updateFilteredTaskListToShowAll();
                return new CommandResult(String.format(MESSAGE_SUCCESS, ""));
            
            case COMPLETED_TASKS :
                model.updateFilteredTaskList("isCompleted");
                return new CommandResult(String.format(MESSAGE_SUCCESS, "completed "));
            
            case OVERDUE_TASKS :
                model.updateFilteredTaskList("isOverdue");
                return new CommandResult(String.format(MESSAGE_SUCCESS, "overdue "));
            
            case FLOATING_TASKS :
                model.updateFilteredTaskList("isFloating");
                return new CommandResult(String.format(MESSAGE_SUCCESS, "floating "));
            
            case TODAY_TASKS :
                filteredListSize = model.updateFilteredTaskList("today");
                if (filteredListSize > 0) {
                    return new CommandResult(String.format(MESSAGE_SUCCESS_2, "today"));
                } else {
                    return new CommandResult(MESSAGE_NO_TASK_TODAY);
                }
            
            case WEEK_TASKS :
                filteredListSize = model.updateFilteredTaskList("week");
                if (filteredListSize > 0) {
                    return new CommandResult(String.format(MESSAGE_SUCCESS_2, "the week"));
                } else {
                    return new CommandResult(MESSAGE_NO_TASK_WEEK);
                }
            
            default:
                return new CommandResult(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }
    }

    /**
     * Parses arguments in the context of the list task command.
     *
     * @param args
     *            full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        try {
            return new ListCommand(args);
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }
    }
}
```
###### \java\seedu\tasklist\logic\commands\MarkCommand.java
``` java
/**
 * Mark a task
 */
public class MarkCommand extends CommandUndoExtension {
    
    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks a task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: \n" + COMMAND_WORD + " 1\n" + COMMAND_WORD + " 2";

    public static final String MESSAGE_MARK_TASK_SUCCESS = "Task marked: %1$s";
    public static final String MESSAGE_MARKED_TASK = "This task is already marked in the task list.";

    public int targetIndex;
    private ReadOnlyTask taskToMark;
    
    public MarkCommand() {};
    
    /**
     * Marks a task identified using it's last displayed index from the task list.
     */
    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToMark = lastShownList.get(targetIndex - 1);

        try {
            model.markTask(taskToMark);
            CommandHistory.addCommandHistory(this);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (TaskCompletionException e) {
            return new CommandResult(MESSAGE_MARKED_TASK);
        }

        return new CommandResult(String.format(MESSAGE_MARK_TASK_SUCCESS, taskToMark));
    }
    
```
###### \java\seedu\tasklist\logic\commands\MarkCommand.java
``` java
    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }

        return new MarkCommand(index.get());
    }   
}
```
###### \java\seedu\tasklist\logic\commands\SelectCommand.java
``` java
    /**
     * Parses arguments in the context of the select task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, MESSAGE_USAGE));
        }

        return new SelectCommand(index.get());
    }

}
```
###### \java\seedu\tasklist\logic\commands\UnmarkCommand.java
``` java
/**
 * Unmark a task
 */
public class UnmarkCommand extends CommandUndoExtension {
    
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmark a task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: \n" + COMMAND_WORD + " 1\n" + COMMAND_WORD + " 2";

    public static final String MESSAGE_UNMARK_TASK_SUCCESS = "Task unmarked: %1$s";
    public static final String MESSAGE_UNMARKED_TASK = "This task is already unmarked in the task list.";

    public int targetIndex;
    private ReadOnlyTask taskToUnmark;
    
    public UnmarkCommand() {};
    
    /**
     * Unmarks a task identified using it's last displayed index from the task list.
     */
    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        taskToUnmark = lastShownList.get(targetIndex - 1);

        try {
            model.unmarkTask(taskToUnmark);
            CommandHistory.addCommandHistory(this);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        } catch (TaskCompletionException e) {
            return new CommandResult(MESSAGE_UNMARKED_TASK);
        }

        return new CommandResult(String.format(MESSAGE_UNMARK_TASK_SUCCESS, taskToUnmark));
    }
    
```
###### \java\seedu\tasklist\logic\commands\UnmarkCommand.java
``` java
    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    @Override
    public Command prepare(String args) {
        Optional<Integer> index = parseIndex(args);
        if(!index.isPresent()){
            return new IncorrectCommand(
                    String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(index.get());
    }
    
}
```
###### \java\seedu\tasklist\logic\Logic.java
``` java
    /** Returns the filtered list of tasks */
    ObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the weekly filtered list of tasks */
    ObservableList<ReadOnlyTask> getMainFilteredTaskList();

}
```
###### \java\seedu\tasklist\logic\LogicManager.java
``` java
    @Override
    public ObservableList<ReadOnlyTask> getFilteredTaskList() {
        return model.getFilteredTaskList();
    }

    @Override
    public ObservableList<ReadOnlyTask> getMainFilteredTaskList() {
        return model.getMainFilteredTaskList();
    }

}
```
###### \java\seedu\tasklist\logic\parser\CommandParser.java
``` java
/**
 * Parser interface for interaction with the Command classes.
 */
public interface CommandParser {

    /**
     * Used for initial separation of command word and args.
     */
    final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");

    final Pattern KEYWORDS_ARGS_FORMAT =
            Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); // one or more keywords separated by whitespace

    // '/' forward slashes are reserved for delimiter prefixes
    final Pattern TASK_DATA_ARGS_FORMAT = 
            Pattern.compile("(?<title>[^/]+)"
                    + "(?<isDescriptionPrivate>p?)(?<description>(?: d/[^/]+)*)"
                    + "(?<isStartDateTimePrivate>p?)(?<startDateTime>(?: s/[^/]+)*)"
                    + "(?<isEndDateTimePrivate>p?)(?<endDateTime>(?: e/[^/]+)*)"
                    + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    
    // '/' forward slashes are reserved for delimiter prefixes
    final Pattern EDIT_TASK_DATA_ARGS_FORMAT = 
            Pattern.compile("(?<targetIndex>[^/\\s]+)"
                    + "(?<title>(?: [^/]+)*)"
                    + "(?<isDescriptionPrivate>p?)(?<description>(?: d/[^/]+)*)"
                    + "(?<isStartDateTimePrivate>p?)(?<startDateTime>(?: s/[^/]+)*)"
                    + "(?<isEndDateTimePrivate>p?)(?<endDateTime>(?: e/[^/]+)*)"
                    + "(?<tagArguments>(?: t/[^/]+)*)"); // variable number of tags
    
    /**
     * Parses arguments in the context of the requested task command.
     * 
     * @param args full command args string
     * @return the prepared command
     */
    public Command prepare(String args);
    
    /**
     * Returns the specified index in the {@code command} IF a positive unsigned integer is given as the index.
     * Returns an {@code Optional.empty()} otherwise.
     */
    default Optional<Integer> parseIndex(String command) {
        final Matcher matcher = TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if(!StringUtil.isUnsignedInteger(index)){
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }
    
    /**
     * Extracts the the task's details from the arguments string
     */
    default String getDetailsFromArgs(String detailsArguments) {
        if (detailsArguments.isEmpty()) {
            return "";
        }
        return detailsArguments.trim().substring(detailsArguments.indexOf("/"), detailsArguments.length()-1);
    }
    
    /**
     * Extracts the task's tags from the tag arguments string.
     * Merges duplicate tag strings.
     */
    default Set<String> getTagsFromArgs(String tagArguments) throws IllegalValueException {
        // no tags
        if (tagArguments.isEmpty()) {
            return Collections.emptySet();
        }
        // replace first delimiter prefix, then split
        final Collection<String> tagStrings = Arrays.asList(tagArguments.replaceFirst(" t/", "").split(" t/"));
        return new HashSet<>(tagStrings);
    }
    
}
```
###### \java\seedu\tasklist\logic\parser\Parser.java
``` java
/**
 * Parses user input.
 */
public class Parser {

    /**
     * Used for initial separation of command word and args.
     */
    private static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = BASIC_COMMAND_FORMAT.matcher(userInput.trim());

        CommandParser incorrectCommandParser = new IncorrectCommand();
        
        if (!matcher.matches()) {
            return incorrectCommandParser.prepare(String.format(Messages.MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        Object object = null;
        try {
            Class<?> classDefinition = Class.forName("seedu.tasklist.logic.commands."
                    + commandWord.substring(0, 1).toUpperCase() + commandWord.substring(1).toLowerCase() + "Command");
            object = classDefinition.newInstance();
            
            return ((CommandParser) object).prepare(arguments);
        } catch (Exception e) {
            return incorrectCommandParser.prepare(Messages.MESSAGE_UNKNOWN_COMMAND);
        }
    }

}
```
###### \java\seedu\tasklist\model\Model.java
``` java
    /** Marks the given task */
    void markTask(ReadOnlyTask target) throws TaskNotFoundException, TaskCompletionException;
    
    /** Unmarks the given task */
    void unmarkTask(ReadOnlyTask target) throws TaskNotFoundException, TaskCompletionException;

    /** Returns the filtered task list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();
    
    /** Returns the filtered task list for list command as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getMainFilteredTaskList();

```
###### \java\seedu\tasklist\model\Model.java
``` java
    /** Updates the filter of the filtered task list to filter by the tasks status*/
    int updateFilteredTaskList(String status);

```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
    @Override
    public void markTask(ReadOnlyTask target) throws TaskNotFoundException, TaskCompletionException {
        taskList.markTask(target);
        indicateTaskListChanged();
    }
    
    @Override
    public void unmarkTask(ReadOnlyTask target) throws TaskNotFoundException, TaskCompletionException {
        taskList.unmarkTask(target);
        indicateTaskListChanged();
    }

```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
    @Override
    public void editTask(Task taskToEdit, ReadOnlyTask target) throws TaskNotFoundException {
        taskList.editTask(taskToEdit, target);
        updateFilteredTaskListToShowAll();
        indicateTaskListChanged();
    }
    
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
    @Override
    public int updateFilteredTaskList(String status){
        updateFilteredTaskList(new PredicateExpression(new TaskStatusQualifier(status)));
        return filteredTask.size();
    }
    
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getMainFilteredTaskList() {
        return new UnmodifiableObservableList<>(mainFilteredTaskList);
    }
```
###### \java\seedu\tasklist\model\ModelManager.java
``` java
    private class TaskStatusQualifier implements Qualifier {
        private String status;
        
        private TaskStatusQualifier(String status) {
            this.status = status;
        }

        @Override
        public boolean run(ReadOnlyTask task) {
            if (status.contains("isCompleted")) {
                return task.isCompleted();
            } else if (status.contains("isOverdue")) {
                return task.isOverdue() && !task.isCompleted();
            } else if (status.contains("isFloating")) {
                return task.isFloating() && !task.isCompleted();
            } else if (status.contains("today")) {
                return task.isOverdue() && !task.isCompleted() || !task.isCompleted() && task.getEndDateTime().isDateEqualCurrentDate() || task.isFloating();
            } else if (status.contains("week")) {
                return task.isOverdue() && !task.isCompleted() || !task.isCompleted() && task.getEndDateTime().isDateEqualCurrentDateTillUpcomingWeek() || task.isFloating();
            } else {
                return false;
            }
        }

        @Override
        public String toString() {
            return "Task status =" + String.join(", ", status);
        }
    }
}
```
###### \java\seedu\tasklist\model\task\DateTime.java
``` java
    /**
     * Check if this date time is after the compared DateTime.
     */
    @Override
    public boolean isDateTimeAfter(DateTime dateTime) {
        return isDateAfter(dateTime) || isDateEqualAndTimeAfter(dateTime) || isNoDateAndTimeAfter(dateTime);
    }

    /**
     * Check if this date is after the compared DateTime's date.
     */
    private boolean isDateAfter(DateTime dateTime) {
        return !isDateEmpty() && !dateTime.isDateEmpty() && getDate().getLocalDate().isAfter(dateTime.getDate().getLocalDate());
    }
    
    /**
     * Check if both dates are equal and the compared DateTime's time is after this object's time
     */
    private boolean isDateEqualAndTimeAfter(DateTime dateTime) {
        return !isDateEmpty() && !isTimeEmpty() && !dateTime.isDateEmpty() && !dateTime.isTimeEmpty()
                && getDate().getLocalDate().isEqual(dateTime.getDate().getLocalDate())
                && (getTime().getLocalTime().equals(dateTime.getTime().getLocalTime())
                || getTime().getLocalTime().isAfter(dateTime.getTime().getLocalTime()));
    }
    
    /**
     * Check if both dates are empty and the compared DateTime's time is after this object's time
     */
    private boolean isNoDateAndTimeAfter(DateTime dateTime) {
        return isDateEmpty() && !isTimeEmpty() 
                && dateTime.isDateEmpty() && !dateTime.isTimeEmpty()
                && getTime().getLocalTime().isAfter(dateTime.getTime().getLocalTime());
    }

    /**
     * Check if this date time is before current local date time.
     */
    @Override
    public boolean isDateTimeAfterCurrentDateTime() {                
        return isDateAfterCurrentDate() || isDateEqualAndTimeAfterCurrentTime() || isNoDateAndTimeAfterCurrentTime();
    }

    /**
     * Check if this date is after the current local date
     */
    private boolean isDateAfterCurrentDate() {
        return !isDateEmpty() && getDate().getLocalDate().isBefore(LocalDate.now());
    }
   
    /**
     * Check if this date is equal to current local date and this time is after the current local time
     */
    private boolean isDateEqualAndTimeAfterCurrentTime() {
        return !isDateEmpty() && !isTimeEmpty() && getDate().getLocalDate().isEqual(LocalDate.now()) 
                && getTime().getLocalTime().isBefore(LocalTime.now());
    }
    
    /**
     * Check if this date is empty and this time is not empty and this time is after the current local time
     */
    private boolean isNoDateAndTimeAfterCurrentTime() {
        return isDateEmpty() && !isTimeEmpty() && getTime().getLocalTime().isBefore(LocalTime.now());
    }

    /**
     * Check if date is equal to current local date.
     */
    @Override
    public boolean isDateEqualCurrentDate() {
        return !isDateEmpty() && getDate().getLocalDate().isEqual(LocalDate.now());
    }
    
    /**
     * Check if date is equal to one week from current local date.
     */
    @Override
    public boolean isDateEqualCurrentDateTillUpcomingWeek() {
        return !isDateEmpty() && getDate().getLocalDate().isAfter(LocalDate.now().minusDays(1))
                && getDate().getLocalDate().isBefore(LocalDate.now().plusWeeks(1));
    }
    
    /**
     * Check if date and time is empty.
     */
    @Override
    public boolean isDateTimeEmpty() {
        return getDate().getLocalDate() == null && getTime().getLocalTime() == null;
    }

    /**
     * Check if date is empty.
     */
    @Override
    public boolean isDateEmpty() {
        return getDate().getLocalDate() == null;
    }

    /**
     * Check if time is empty.
     */
    @Override
    public boolean isTimeEmpty() {
        return getTime().getLocalTime() == null;
    }

```
###### \java\seedu\tasklist\model\task\DateTimeComparator.java
``` java
/**
 * A immutable interface for comparing a Task's DateTime in the task list.
 */
public interface DateTimeComparator {

    /**
     * Check if date time is after the compared DateTime.
     */
    public boolean isDateTimeAfter(DateTime dateTime);

    /**
     * Check if date time is before current local date time.
     */
    public boolean isDateTimeAfterCurrentDateTime();
    
    /**
     * Check if date is equal to current local date.
     */
    public boolean isDateEqualCurrentDate();
    
    /**
     * Check if date is equal to one week from current local date.
     */
    public boolean isDateEqualCurrentDateTillUpcomingWeek();

    /**
     * Check if date and time is empty.
     */
    public boolean isDateTimeEmpty();
    
    /**
     * Check if date is empty.
     */
    public boolean isDateEmpty();
    
    /**
     * Check if time is empty.
     */
    public boolean isTimeEmpty();

}
```
###### \java\seedu\tasklist\model\task\ReadOnlyTask.java
``` java
    boolean isCompleted();
    boolean isOverdue();
    boolean isFloating();

```
###### \java\seedu\tasklist\model\task\ReadOnlyTask.java
``` java
    /**
     * Formats the task as text, showing all details.
     */
    default String getAllAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Title: ")
                .append(getTitle())
                .append("\nDescription: ")
                .append(getDescription())
                .append("\nStart: ")
                .append(getStartDateTime())
                .append("\nEnd: ")
                .append(getEndDateTime())
                .append("\nTags: ");
        getTags().forEach(builder::append);
        builder.append("\nCompleted: ")
                .append(isCompleted());
        return builder.toString();
    }

```
###### \java\seedu\tasklist\model\task\Task.java
``` java
    /**
     * Check whether startDateTime is before endDateTime
     * 
     * @throws IllegalValueException if startDateTime is before endDateTime
     */
    private void validateDateTime(DateTime startDateTime, DateTime endDateTime) throws IllegalValueException {
        if (startDateTime.isDateTimeAfter(endDateTime)) {
            throw new IllegalValueException(Messages.MESSAGE_INVALID_DATE_TIME_ENTRY);
        }
    }
    
    /**
     * Initialize overdue task status 
     */
    private void initializeOverdue() {
        if (this.endDateTime.isDateTimeAfterCurrentDateTime()) {
            this.isOverdue = true;
        } else {
            this.isOverdue = false;
        }
    }
    
    /**
     * Initialize floating task status
     */
    private void initializeFloating() {
        if (this.startDateTime.isDateTimeEmpty() && this.endDateTime.isDateTimeEmpty()) {
            this.isFloating = true;
        } else {
            this.isFloating = false;
        }
    }
    
```
###### \java\seedu\tasklist\model\task\UniqueTaskList.java
``` java
    /**
     * Sort the internal list in ascending end date time with floating tasks at the end.
     */
    private void sort() {
        List<Task> completedList = internalList.stream().filter(t -> t.isCompleted()).collect(Collectors.toList());
        internalList.removeAll(completedList);
        
        List<Task> floatingList = internalList.stream().filter(t -> t.isFloating()).collect(Collectors.toList());
        internalList.removeAll(floatingList);
        
        internalList.sort(new Comparator<Task>() {
            @Override
            public int compare(Task t1, Task t2) {
                if (!t1.getEndDateTime().isDateEmpty() && !t2.getEndDateTime().isDateEmpty() 
                        && t1.getEndDateTime().isDateTimeAfter(t2.getEndDateTime())) {
                    return 1;
                } else {
                    return 0;
                } 
            }
        });
        
        internalList.addAll(floatingList);
        internalList.addAll(completedList);
    }
    
```
###### \java\seedu\tasklist\model\task\UniqueTaskList.java
``` java
    /**
     * Edits the equivalent task and sorts the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     */
    public void edit(Task taskToEdit, ReadOnlyTask toEdit) throws TaskNotFoundException {
        assert toEdit != null;
        assert taskToEdit != null;
        final int notFoundInList = -1;
        
        int index = internalList.lastIndexOf(toEdit);
        if (index == notFoundInList) {
            throw new TaskNotFoundException();
        }
        internalList.set(index, taskToEdit);
        sort();
    }
    
```
###### \java\seedu\tasklist\model\task\UniqueTaskList.java
``` java
    /**
     * Mark the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws TaskCompletionException if task is already completed in the list.
     */
    public boolean mark(ReadOnlyTask toMark) throws TaskNotFoundException, TaskCompletionException {
        assert toMark != null;
        final int taskNotFound = -1;
        
        final int index = internalList.indexOf(toMark);
        if (index == taskNotFound) {
            throw new TaskNotFoundException();
        } else if (internalList.get(index).isCompleted()) {
            throw new TaskCompletionException();
        }
        
        final Task completeTask = internalList.get(index);
        completeTask.setCompleted(true);
        internalList.set(index, completeTask);
        sort();
        
        return true;
    }
    
    /**
     * Unmark the equivalent task from the list.
     *
     * @throws TaskNotFoundException if no such task could be found in the list.
     * @throws TaskCompletionException if task is already completed in the list.
     */
    public boolean unmark(ReadOnlyTask toUnmark) throws TaskNotFoundException, TaskCompletionException {
        assert toUnmark != null;
        final int taskNotFound = -1;
        
        final int index = internalList.indexOf(toUnmark);
        if (index == taskNotFound) {
            throw new TaskNotFoundException();
        } else if (!internalList.get(index).isCompleted()) {
            throw new TaskCompletionException();
        }
        
        final Task completeTask = internalList.get(index);
        completeTask.setCompleted(false);
        internalList.set(index, completeTask);
        sort();
        
        return true;
    }
    
```
###### \java\seedu\tasklist\model\TaskList.java
``` java
    /**
     * Edits a task in the task list.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     * 
     * @throws TaskNotFoundException if task does not exist.
     */
    public void editTask(Task taskToEdit, ReadOnlyTask key) throws TaskNotFoundException {
        syncTagsWithMasterList(taskToEdit);
        task.edit(taskToEdit, key);
    }

    /**
     * Mark a task in the task list.
     * 
     * @throws TaskNotFoundException if task does not exist.
     */
    public boolean markTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException, TaskCompletionException {
        if (task.mark(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    
    /**
     * Unmark a task in the task list.
     * 
     * @throws TaskNotFoundException if task does not exist.
     */
    public boolean unmarkTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException, TaskCompletionException {
        if (task.unmark(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    
```
###### \java\seedu\tasklist\storage\XmlAdaptedTask.java
``` java
/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String title;
    @XmlElement(required = true)
    private String description;
    @XmlElement(required = true)
    private String startDateTime;
    @XmlElement(required = true)
    private String endDateTime;
    @XmlElement(required = true)
    private boolean isCompleted;
    @XmlElement(required = true)
    private boolean isOverdue;
    @XmlElement(required = true)
    private boolean isFloating;

    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        title = source.getTitle().fullTitle;
        description = source.getDescription().description;
        startDateTime = source.getStartDateTime().toString().replaceAll(":", "").replaceAll("-", "");
        endDateTime = source.getEndDateTime().toString().replaceAll(":", "").replaceAll("-", "");
        isCompleted = source.isCompleted();
        isOverdue = source.isOverdue();
        isFloating = source.isFloating();
        tagged = new ArrayList<>();
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
        final Title title = new Title(this.title);
        final Description description = new Description(this.description);
        final DateTime startDateTime = new DateTime(this.startDateTime);
        final DateTime endDateTime = new DateTime(this.endDateTime);
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(title, startDateTime, description, endDateTime, tags, this.isCompleted, this.isOverdue, this.isFloating);
    }
}
```
###### \java\seedu\tasklist\ui\CommandBox.java
``` java
    /**
     * Restores the command box text to the previously entered command
     */
    private void restoreCommandText() {
        commandTextField.setText(previousCommandList.get(previousCommandIndex));
        previousCommandList.remove(previousCommandIndex);
    }

    /**
     * Select and restores the command box text to the previously entered
     * command for the Up key
     */
    public void selectPreviousCommandTextNext() {
        if (!previousCommandList.isEmpty()) {
            commandTextField.setText(previousCommandList.get(previousCommandIndex));
            if (previousCommandIndex < previousCommandList.size() - 1) {
                previousCommandIndex++;
            }
        }
    }

    /**
     * Select and restores the command box text to the previously entered
     * command for the Down key
     */
    public void selectPreviousCommandTextPrevious() {
        if (!previousCommandList.isEmpty()) {
            commandTextField.setText(previousCommandList.get(previousCommandIndex));
            if (previousCommandIndex > 0) {
                previousCommandIndex--;
            }
        }
    }

```
###### \java\seedu\tasklist\ui\MainWindow.java
``` java
    private void setAccelerators() {
        mainMenuItem.setAccelerator(KeyCombination.valueOf("F11"));
        
        helpMenuItem.setAccelerator(KeyCombination.valueOf("F1"));
        
        commandNextMenuItem.setAccelerator(KeyCombination.valueOf("UP"));
        commandPreviousMenuItem.setAccelerator(KeyCombination.valueOf("DOWN"));
        
        filteredListFirstMenuItem.setAccelerator(KeyCombination.valueOf("Home"));
        filteredListLastMenuItem.setAccelerator(KeyCombination.valueOf("End"));
        filteredListPreviousMenuItem.setAccelerator(KeyCombination.valueOf("Page Up"));
        filteredListNextMenuItem.setAccelerator(KeyCombination.valueOf("Page Down"));
        
        mainListFirstMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl+Home"));
        mainListLastMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl+End"));
        mainListPreviousMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl+Page Up"));
        mainListNextMenuItem.setAccelerator(KeyCombination.valueOf("Ctrl+Page Down"));
    }

    private void addEventFilters() {
        scene.addEventFilter(KeyEvent.KEY_PRESSED, (event) -> {
            Map<KeyCombination,Runnable> accelerators = scene.getAccelerators();
            for (KeyCombination keyCombination : accelerators.keySet()) {
                if (keyCombination.match(event)) {
                    accelerators.get(keyCombination).run();
                    event.consume();
                    return;
                }
            }
        });
    }

    public void fillInnerParts() {      
        mainTaskListPanel = TaskListPanel.load(primaryStage, mainTaskListPanelPlaceholder, logic.getMainFilteredTaskList(), TaskListPanel.Type.MAIN_TASKLIST);
        filteredTaskListPanel = TaskListPanel.load(primaryStage, getTaskListPlaceholder(), logic.getFilteredTaskList(), TaskListPanel.Type.FILTERED_TASKLIST);
        resultDisplay = ResultDisplay.load(primaryStage, getResultDisplayPlaceholder());
        statusBarFooter = StatusBarFooter.load(primaryStage, getStatusbarPlaceholder(), config.getTaskListFilePath(), logic.getMainFilteredTaskList());
        commandBox = CommandBox.load(primaryStage, getCommandBoxPlaceholder(), resultDisplay, logic);
    }

```
###### \java\seedu\tasklist\ui\MainWindow.java
``` java
    /**
     * Scroll to the first task in the main tasks list view
     */
    @FXML
    private void handleMainListPanelScrollToFirst() {
        mainTaskListPanel.scrollToFirst();
    }
    
    /**
     * Scroll to the last task in the main tasks list view
     */
    @FXML
    private void handleMainListPanelScrollToLast() {
        mainTaskListPanel.scrollToLast();
    }
    
    /**
     * Scroll up in the main tasks list view
     */
    @FXML
    private void handleMainListPanelScrollUp() {
        mainTaskListPanel.scrollToPrevious();
    }
    
    /**
     * Scroll down in the main tasks list view
     */
    @FXML
    private void handleMainListPanelScrollDown() {
        mainTaskListPanel.scrollToNext();
    }
    
    /**
     * Scroll to the first task in the filtered tasks list view
     */
    @FXML
    private void handleFilteredListPanelScrollToFirst() {
        filteredTaskListPanel.scrollToFirst();
    }
    
    /**
     * Scroll to the last task in the filtered tasks list view
     */
    @FXML
    private void handleFilteredListPanelScrollToLast() {
        filteredTaskListPanel.scrollToLast();
    }
    
    /**
     * Scroll up in the filtered tasks list view
     */
    @FXML
    private void handleFilteredListPanelScrollUp() {
        filteredTaskListPanel.scrollToPrevious();
    }
    
    /**
     * Scroll down in the filtered tasks list view
     */
    @FXML
    private void handleFilteredListPanelScrollDown() {
        filteredTaskListPanel.scrollToNext();
    }
    
    /**
     * Set the main Window into and out of full screen mode
     */
    @FXML
    private void handleFullScreen() {
        if (primaryStage.isFullScreen()) {
            primaryStage.setFullScreen(false);
        } else {
            primaryStage.setFullScreen(true);
        }
    }

    /**
     * Scroll through the previous commands by pressing the Up Key
     */
    @FXML
    private void handlePreviousCommandTextNext() {
        commandBox.selectPreviousCommandTextNext();
    }

    /**
     * Scroll through the previous commands by pressing the Down Key
     */
    @FXML
    private void handlePreviousCommandTextPrevious() {
        commandBox.selectPreviousCommandTextPrevious();
    }

```
###### \java\seedu\tasklist\ui\TaskCard.java
``` java
    @FXML
    public void initialize() {
        initializeId();
        initializeTitle();
        initializeDateTime();
        initializeDescription();
        initializeTags();
        setStyle();
    }
    
    private void initializeId() {
        if (isNotRequired) {
            id.setText(null);
        } else {
            id.setText(displayedIndex + ". ");
        }
    }
    
    private void initializeTitle() {
        name.setText(task.getTitle().fullTitle);
    }
    
    private void initializeDescription() {
        description.setText(task.getDescription().description);
        
        if (task.getDescription().description.equals("") || isNotRequired) {
            description.setManaged(false);
        } else {
            description.setManaged(true);
        }
    }

    private void initializeDateTime() {
        startDateTime.setText("Start:  " + task.getStartDateTime().toString().replaceAll(" ", "    Time:  "));
        
        if (task.getStartDateTime().toString().isEmpty() || (isNotRequired && task.isCompleted())) {
            startDateTime.setManaged(false);
        } else {
            startDateTime.setManaged(true);
        }
        
        endDateTime.setText("End:    " + task.getEndDateTime().toString().replaceAll(" ", "    Time:  "));
        
        if(task.getEndDateTime().toString().isEmpty() || (isNotRequired && task.isCompleted())) {
            endDateTime.setManaged(false);
        } else {
            endDateTime.setManaged(true);
        }
    }
    
    private void initializeTags() {
        tags.setText(task.tagsString());
        if (task.isCompleted()) {
            tags.setManaged(false);
        } else {
            tags.setManaged(true);
        }
    }
    
    public void setStyle() {
        if (task.isCompleted()) {
            cardPane.setStyle(FX_BACKGROUND_PALE_GREEN);
        } else if (task.isFloating()) {
            cardPane.setStyle(FX_BACKGROUND_PALE_YELLOW);
        } else if (task.isOverdue()){
            cardPane.setStyle(FX_BACKGROUND_PALE_RED);
        } else {
            cardPane.setStyle(FX_BACKGROUND_WHITE);
        }
    }
    
```
###### \java\seedu\tasklist\ui\TaskListPanel.java
``` java
    public void scrollTo(int index) {
        taskListView.scrollTo(index);
    }

    public void scrollToPrevious() {
        if (scrollIndex > 0) {
            scrollTo(--scrollIndex);
        }
    }

    public void scrollToNext() {
        if (scrollIndex < taskListSize - 1) {
            scrollTo(++scrollIndex);
        }
    }
    
    public void scrollToLast() {
        scrollIndex = taskListSize - 1;
        scrollTo(scrollIndex);
    }
    
    public void scrollToFirst() {
        scrollIndex = 0;
        scrollTo(scrollIndex);
    }

    class TaskListViewCell extends ListCell<ReadOnlyTask> {

        public TaskListViewCell() {
        }

        @Override
        protected void updateItem(ReadOnlyTask task, boolean empty) {
            super.updateItem(task, empty);

            if (empty || task == null ) {
                setGraphic(null);
                setText(null);
            } else if (type == TaskListPanel.Type.FILTERED_TASKLIST){
                setGraphic(TaskCard.load(task, getIndex() + 1).getLayout());
            } else if (type == TaskListPanel.Type.MAIN_TASKLIST){
                if (task.isCompleted()) {
                    setGraphic(null);
                    setText(null);
                } else {
                    setGraphic(TaskCard.load(task, -1).getLayout());
                }
            }
        }
    }

```
###### \resources\view\MainWindow.fxml
``` fxml
            <Menu mnemonicParsing="false" text="File">
               <items>
                  <MenuItem fx:id="mainMenuItem" mnemonicParsing="false" onAction="#handleFullScreen" text="FullScreen" />
                  <SeparatorMenuItem/>
                  <MenuItem mnemonicParsing="false" onAction="#handleExit" text="Exit" />
               </items>
            </Menu>
            <Menu mnemonicParsing="false" text="Navigate">
               <items>
                  <Menu mnemonicParsing="false" text="Commands">
                     <items>
                        <MenuItem fx:id="commandNextMenuItem" mnemonicParsing="false" onAction="#handlePreviousCommandTextNext" text="Show Previous Command" />
                        <MenuItem fx:id="commandPreviousMenuItem" mnemonicParsing="false" onAction="#handlePreviousCommandTextPrevious" text="Show Previous Command" />
                     </items>
                  </Menu>
                  <Menu mnemonicParsing="false" text="Interactive Tasklist">
                     <items>
	                    <MenuItem fx:id="filteredListFirstMenuItem" mnemonicParsing="false" onAction="#handleFilteredListPanelScrollToFirst" text=" Scroll to Top" />
	                    <MenuItem fx:id="filteredListLastMenuItem" mnemonicParsing="false" onAction="#handleFilteredListPanelScrollToLast" text=" Scroll to Bottom" />
	                    <MenuItem fx:id="filteredListPreviousMenuItem" mnemonicParsing="false" onAction="#handleFilteredListPanelScrollUp" text=" Scroll Up" />
	                    <MenuItem fx:id="filteredListNextMenuItem" mnemonicParsing="false" onAction="#handleFilteredListPanelScrollDown" text=" Scroll Down" />
                     </items>
                  </Menu>
                  <Menu mnemonicParsing="false" text="Overall Tasklist">
	                 <items>
	                    <MenuItem fx:id="mainListFirstMenuItem" mnemonicParsing="false" onAction="#handleMainListPanelScrollToFirst" text=" Scroll to Top" />
	                    <MenuItem fx:id="mainListLastMenuItem" mnemonicParsing="false" onAction="#handleMainListPanelScrollToLast" text=" Scroll to Bottom" />
	                    <MenuItem fx:id="mainListPreviousMenuItem" mnemonicParsing="false" onAction="#handleMainListPanelScrollUp" text=" Scroll Up" />
	                    <MenuItem fx:id="mainListNextMenuItem" mnemonicParsing="false" onAction="#handleMainListPanelScrollDown" text=" Scroll Down" />
	                </items>
                  </Menu>
               </items>
```
###### \resources\view\MainWindow.fxml
``` fxml
            <VBox fx:id="filteredTaskList" minWidth="340" prefWidth="340">
                <padding>
                    <Insets bottom="10.0" left="10.0" right="10.0" top="10.0"/>
                </padding>
               <children>
                  <AnchorPane fx:id="filteredTaskListPanelPlaceholder" VBox.vgrow="ALWAYS"/>
               </children>
            </VBox>
            <VBox fx:id="mainTaskList" minWidth="340" prefWidth="340">
                <padding>
	               <Insets top="10" bottom="10" left="10" right="10"/>
	            </padding>
	            <children>
		            <AnchorPane fx:id="mainTaskListPanelPlaceholder" VBox.vgrow="ALWAYS"/>
	            </children>
            </VBox>
```
